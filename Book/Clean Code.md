# Clean Code

내맘대로 정리한 클린코드

## Chapter 01 - 깨끗한 코드
* 나쁜코드가 쌓일수록 그 팀의 생산성은 떨어지고 이윽고 0에 수렴한다.
* 나쁜코드는 난장판을 더 키운다.(깨진 유리창 이론)
* 결국, 회사가 망할수 도 있다........ㅠ
* 빨리 가기 위한 단 하나의 방법은 "최대한 깨끗한 코드를 항상 유지하는 것"
* Clean Code란 무엇인가?
    * Clean Code는 하나의 잘 쓰여진 산문처럼 읽혀야 한다. 읽고, 끄덕이고, 다음으로 넘어갈 수 있는 코드.
    * 나쁜 코드는 여러가지 일을 하려고 한다. 애매한 의도와 목적을 포함한다. 따라서, 클린 코드는 한가지 일을 잘해야한다.
    * 코드를 care하라!
    * 중복을 없애라
* 우리는 작가들이다
    * 실제로 읽기와 쓰기에 걸리는 시간은 9:1 정도
    * 읽기 쉽게 작성하자!

## Chapter 02 - 의미 있는 이름
* 의도를 밝혀라
  * 독자가 사전지식이 없음애도 의미를 파악할 수 있어야한다.
```java
List<Integer> list1 = new ArrayList<>();    //bad
List<Integer> flaggedCells = new ArrayList<>();     //good
```

* 의미있게 구분하라
  * Info, Data 이런거 붙이지 말자.
  * ex) Account, AccountInfo (이들이 혼재할 경우 역할을 구분하기 어렵다 ㅠㅠ)
* 발음하기 쉬운 이름을 사용하자
* 클래스 이름
  * 명사 혹은 명사구
  * Data, Info 등은 지양하자
* 메서드 이름
  * 동사 혹은 동사구
  
## Chapter 03 - 함수
* 작게 만들자(쪼개자)
  * 3~5줄 권장...
* 블록과 들여쓰기
  * 중첩구조(if/else, while 문 등) 들여쓰기 수준이 2단을 넘지 않도록 하자.
* 함수가 한가지 작업만 하도록 하자
* 함수 내 추상화 수준은 하나로
  * 함수 추상화 수준(레벨)이 한번에 한단계씩 낮아지는 것이 가장 이상적이다.
```java
public Money calculatePay(Employee e) throws InvalidEmployeeType {
	switch (e.type) { 
		case COMMISSIONED:
			return calculateCommissionedPay(e);     // 같은 레벨
		case HOURLY:
			return calculateHourlyPay(e);   // 같은 레벨
		case SALARIED:
			return calculateSalariedPay(e);     // 같은 레벨
		default:
			throw new InvalidEmployeeType(e.type);  // 같은 레벨
	}
}
```
* 함수 인수(파라미터)
  * 플래그 인수를 사용하지 말자.
  * 파라미터의 갯수는 적을수록 이상적이다.
  * 출력인수(ex. 참조변수)등은 사용하지 말자. 이해의 어려움을 줄 수 있다.
  * 인수가 많다면 차라리 객체로 만들어서 던져라.
  * 동사와 키워드
    * 단항함수는 함수와 인수가 동사/명사 쌍을 이뤄야한다. 
        ```java 
        print(name); // print = 동사, name = 명사
        ```
    * 함수이름에 키워드를 추가하면 파라미터 순서를 기억안해도 된다. 
        ```java 
        assertExpectedEqualsActual(expected, actual);
        ```
* 부수 효과를 일으키지 마라
* 오류코드보다 예외를 사용하자
  * Try/Catch 블록 뽑아내기.
* 반복하지 마라!!!!!

## Chapter 04 - 주석
* 주석은 나쁜코드를 보완하지 못한다
  * 코드로 의도를 표현하지 못해 실패를 만회하기 위해 쓰는것
  * 주석을 무시하는 이유는 유지보수하기 어렵기 때문
  * 코드는 바뀌는데 주석은 그대로라면? 거짓말을 하게 될 가능성이 커지니까!
* 좋은 주석은..
  * 법적인 주석
  * 정보를 제공하는 주석
  * 의도를 설명하는 주석
  * TODO 주석
  * 결과를 경고하는 주석
    ```java
    //여유시간이 충분치 않으면 실행하지 마세요..
    ```
  * 등등..  
* 나쁜 주석은..
  * 오해 여지가 있는 주석
  * 의무적으로 다는 주석
  * 이력을 기록하는 주석
  * 있으나 마나 한 주석
  * 위치를 표시하는 주석
  * 주석으로 처리한 코드
  * 등등..
  
## Chapter 05 - 형식 맞추기
* 형식을 맞추는 목적
  * 코드 형식은 의사소통의 일환
  * 코드는 사라져도 스타일과 규율은 사라지지 않는다.
* 신문 기사처럼 작성하라
  * 고차원에서 저차원으로
  * 내려갈수록 의도를 세세하게
* 세로 밀집도
  * 연관성이 깊을수록 밀집시킨다.
* 변수선언
  * 사용하는 위치에서 최대한 가까이에 둔다.
* 종속함수
  * 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치할 것
* 개념의 유사성
  * 개념적인 친화도가 높을수록 서로 가까이 배치한다.
* 팀 규칙을 잘 정하자!

## Chapter 06 - 객체와 자료구조
* 디미터 법칙
  * 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙

## Chapter 07 - 에러 핸들링
* Return Code 대신 Exceptions 사용
  * "실제로직"과 "예외처리" 부분이 나뉘어져 필요한 부분에 집중할 수 있다
* 사용에 맞게 Exception 클래스를 선언하라
  * 정말 필요한 경우에만 추가하자. 보통 특정 부분의 코드는 하나의 클래스로 충분히 처리가 가능하다.
* Null을 리턴 하지마라
  * 또한, Null을 넘기지 마라. 이건 더 나쁘다.

## Chapter 09 - 단위 테스트
* TDD를 적용 하다보면 실제코드를 사실상 전부테스트 해야하는 케이스가 나온다. 이는 너무 방대하고, 심각한 관리 문제를 유발하기도 한다.
* 테스트는 유연성, 유지보수성, 재사용성을 제공한다.
  * 테스트 커버리지는 개발자에게 자신감을 준다.
  * 테스트 케이스를 토앻 변경이 쉬워진다.
* 테스트 코드도 가독성이 중요하다.
* 테스트 당 개념은 하나
* 깨끗한 테스트의 5가지 규칙(F.I.R.S.T)
  1) Fast(빠르게) : 테스트는 빠르게 돌아야한다.
  2) Independent(독립적으로) : 테스트 간에 의존하면 안된다
  3) Repeatable(반복가능하게) : 어떤 환경에서건 반복 가능해야한다.
  4) Self-Validating(자가검증) : 성공 아니면 실패다. 다른 짓 하지 말자.
  5) Timely(적시에) : 실제코드를 구현하기 직전에 구현한다.

## Chapter 10 - 클래스
* 클래스는 작아야한다.
  * 클래스의 책임을 기술해보자. 작명 시 간결한 이름이 떠오르지 않는다면, 클래스 책임이 너무 많아서 그렇다.
    * ex) Manager, Processor, Super 등 ..
* 응집도
  * 응집도가 높다 = 메서드와 변수가 서로 의존핳며 논리적인 단위로 묶인다.

## Chapter 12 - 창발성
* 창발성?
  * 단순한 결합이 복잡한 결과(긍정적으로)를 나타내는 것을 의미 (ex. 수십억개의 뉴런이 모여 자기인식이 된다)
  * 창발적 설계란 어떤 규칙과 원칙에 따라 설계를 하게 되면, 그것들이 모여 좋은 거시적 설계가 된다.
* 켄트백의 단순한 설계
  * 소프트웨어 설계 품질을 크게 높여준다고 믿음
    1) 모든 테스트를 실행가능하게 하자 + 리팩토링
    2) 중복제거를 통해 복잡성을 최소화
    3) 프로그래머의 의도를 분명하게 표현하자
    4) 클래스와 메서드를 최소한으로 줄인다
  
## Chapter 13 - 동시성
* 동시성 방어 원칙
  * Concurrency 관련 코드는 다른코드들과 분리하자(SRP)
  * 공유될만한 자원에 접근하는 부분(Critical Section) 코드들을 극도로 줄이자
  * 자원의 복사본을 사용하자
    * 복사본을 여러 스레드에 전달 후, 단일 스레드에서 이를 수집하는 방식
    * 객체의 복제에 사용되는 비용은 일반적으로 동기화 처리 보다 비용이 적게든다.
  * 스레드 코드를 공유자원을 사용하지 않도록 구현(가능하다면 ㅎㅎ)
* 라이브러리에 대한 이해
  * 스레드 환경에 안전한 컬렉션 사용 (ex. StringBuffer, ConcurrentHashMap ..)
* 동기화 하는 부분을 작게 만들자
* 스레드 코드 테스트하기
  * 말이 안되는 문제는 잠정적 스레드 문제로 취급하자
    * 이해하기 어려운 버그가 발생하고, 직관적으로 파악하기 어렵기 때문이다.
  * 우선 단일 스레드에서 제대로 동작하게 만들자
  * 다양한 환경에서 실행가능하게 만들자.
    * 단일스레드, 여러스레드, 수행속도, 지정된 횟수 등...
  * 프로세서 수보다 많은 스레드 환경을 테스트하자
    * 데드락 같은 것을 발견할 수도 있다.
  * 다중 OS에서 돌려보자
    * OS마다 다르게 동작할 수도 있다.